import os
import json
from config import *
import vertexai
from vertexai.generative_models import GenerativeModel
import vertexai.preview.generative_models as generative_models
import jsonschema
import utils

class ExtractConfigClient:
    def __init__(self):
        """Initializes the ExtractConfigClient with the Gemini model."""
        self.schema = load_activity_config_schema()
        vertexai.init(project=PROJECT_ID, location=LOCATION)
        self.model = GenerativeModel(os.getenv("GEMINI_MODEL"),
            system_instruction="""You are an expert in extracting configuration details for an e-learning platform from text. You will be given a JSON configuration schema, text input from an educator containing data to extract, and the current JSON configuration to be modified."""
        )

    def extract_values(self, prev_system_response, user_input, current_config):
        """Extracts configuration values from the given text based on the structure.

        Args:
            text: The text input describing the configuration.
            current_config: The current configuration structure.

        Returns:
            The extracted configuration as a JSON object.
        """

        print(f"Processing, please wait...")

        payload = {
            "config_schema": self.schema,
            "prev_system_response": prev_system_response,
            "user_input": user_input,
            "current_config": current_config
        }

        json_payload = json.dumps(payload, indent=2)
        prompt = (
            "The following is a JSON object containing the schema, the user input text, and the current configuration:\n\n"
            f"{json_payload}\n\n"
            "1. Extract the relevant information from the user input text, given in response to the 'prev_system_response' text.\n"
            f"2. If changes were proposed, update the current configuration using the extracted values, otherwise, keep the current config 'as is'.\n"
            "   - Slightly spread out accounts in the same phase, but ensure x and y locations remain within clamped ranges.\n"
            "   - Resource changes requested for a phase should be made to the board associated with that phase).\n"
            "3. Return the configuration as a JSON object, ensuring the JSON is valid, e.g.:\n"
            "   - Close the opening curly brace by ensuring final curly brace is added.\n"
            "   - Ensure it does not contain any extra characters or formatting.\n"
        )

        # Call the model and process response
        generation_config = {
            "max_output_tokens": 4096,
            "temperature": 0.2,
            "top_p": 0.95,
            "top_k": 40
        }

        safety_settings = {
            generative_models.HarmCategory.HARM_CATEGORY_HATE_SPEECH: generative_models.HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
            generative_models.HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT: generative_models.HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
            generative_models.HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT: generative_models.HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
            generative_models.HarmCategory.HARM_CATEGORY_HARASSMENT: generative_models.HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
        }
        
        # Call the model to predict and get results in string format
        response = self.model.generate_content(prompt, generation_config=generation_config, safety_settings=safety_settings).text
        clean_response = utils.remove_json_markdown(response)

        try:
            extracted_config = json.loads(clean_response)
            jsonschema.validate(instance=extracted_config, schema=self.schema)
        except json.decoder.JSONDecodeError as e:
            if "Expecting ',' delimiter" in str(e):
                # Attempt to fix missing comma error by adding closing curly brace
                clean_response += "}"
                print(f"Attempting to fix missing closing curly brace:\n{clean_response}")

                try:
                    extracted_config = json.loads(clean_response)
                    jsonschema.validate(instance=extracted_config, schema=self.schema)
                except json.decoder.JSONDecodeError as e2:
                    print(f"Error parsing LLM output as JSON after fix attempt: {e2}")
                    return {}  # Or some other default value
                except jsonschema.exceptions.ValidationError as e2:
                    # If still invalid after the fix attempt, raise the original error
                    raise ValueError(f"Invalid configuration generated by LLM: {e}")
            else:
                raise ValueError(f"Invalid configuration generated by LLM: {e}")

        return extracted_config
